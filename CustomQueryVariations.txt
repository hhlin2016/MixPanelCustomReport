      var params = {
        "from_date": "2015-04-06",
        "to_date": "2016-04-06",
        "event": "App Started"
      };

// Use a combination of filters and groupBy to determine what is available. I.E. If looking for the App List while device model is set, would filter by device model and groupby App Name.
// This could cause complications however as this could strictly refine the search unless the user clears things.

/*
Platform -> App Name -> Model
if Platform is changed, clear App Name and Model
if App Name changes, clear only Model
if Model changes, do nothing
*/
function main() { 					return Events({from_date: params.from_date,						to_date: params.to_date,						event_selectors: [{event: params.event}]}).filter(function(event) { return (event.name === params.event ) })
.groupBy(["properties.Platform"], mixpanel.reducer.count())
//.filter(function(event) { return ((event.properties.Platform === '2' ) ) })
/*
.reduce(function(previousData, object){							
  var allData = [];								
  var total = 0;								
  for (var i = 0; i < previousData.length;i++){									
    var elementPreviousData = previousData[i];									
    for (var j = 0; j < elementPreviousData.length;j++){										
      allData.push(elementPreviousData[j]);									
      
    }								
    
  }								
  for (i=0; i<object.length; i++){									
    var element = object[i].key["0"];									
    allData.push(element);								
    
  }								
  return allData;							
  
})
*/

/*

function main() {
        return Events({
          from_date: params.from_date,
          to_date: params.to_date,
          event_selectors: [{event: params.event}]
        })
        .filter(function(event) { return (event.name === params.event ) })
//        .filter(function(event) { return ((event.properties.Platform === 'Kindle') ) })
//        .filter(function(event) { return ((event.properties["App Name"] === 'Sago Mini Friends') ) })
//        .filter(function(event) { return ((event.properties.$model === 'LG-D415') ) })
//        .groupBy(["properties.App Name"], mixpanel.reducer.count()) // Get App Names
//        .groupBy(["properties.Platform"], mixpanel.reducer.count()) // Get Model Names
        .groupBy(["properties.$model"],mixpanel.reducer.count())
//        .groupBy(["key.1"], mixpanel.reducer.count()) // Key.1 is the key from the groupByUser search
//        .reduce(mixpanel.reducer.count());

.reduce(function(previousData, object){
								var allData = [];
								var total = 0;
								for (var i = 0; i < previousData.length;i++){
									var elementPreviousData = previousData[i];
									for (var j = 0; j < elementPreviousData.length;j++){
										allData.push(elementPreviousData[j]);
									}
								}
								for (i=0; i<object.length; i++){
									var element = object[i].key['0'];
									allData.push(element);
								}
								return allData;
							})
*/							
        /*
				.reduce(function(previousData, object){
						var allData = [];
						var total = 0;
						for (var i = 0; i < previousData.length;i++){
							var elementPreviousData = previousData[i];
							for (var j = 0; j < elementPreviousData.length;j++){
								allData.push(elementPreviousData[j]);
							}
						}
						for (i=0; i<object.length; i++){
							var element = [object[i].key["0"]];
							allData.push(element);
						}
						return allData;
					})
					*/
        /*
        .reduce(function(states, object){

          var partialData = [];
          var allData = [];
          var total = 0;
         //throw Object.keys(object)
          for (i=0; i<object.length; i++){
            
            //total = total + object[i].value;
            var element = [object[i].key['0'], object[i].value];
            partialData.push(element);
          }
//          partialData.sort(sortByValue);
          /*
          for (i=0; i<object.length; i++){
            var newElement = [i+1, partialData[i][0], partialData[i][1], parseFloat(partialData[i][1]/total*100).toFixed(2)];
            allData.push(newElement);
          }
          
          
          return partialData;
        })
        
        .map(function(event){
    			function sortByValue(a, b) {
    				if (a[1] === b[1]) {
    					return 0;
    				}
    				else {
    					return (a[1] < b[1]) ? 1 : -1;
    				}
    			}
    			var allData = [];
    			var total = 0;
          event.sort(sortByValue);
          
          for (var i = 0; i < event.length; i++){
            total += event[i][1];
          }
          
          for (i = 0; i < event.length; i++){
            
            var element = [i+1, event[i][0], event[i][1], parseFloat(event[i][1] / total * 100).toFixed(2)];
            allData.push(element);
          }
          return allData;
        })
        */
}
/*
// NOTE: For groupBy, MUST use properties.variable instead of properties["variable"] otherwise it returns null!
function main() {
        return Events({
          from_date: params.from_date,
          to_date: params.to_date,
          event_selectors: [{event: params.event}]
        })
        .filter(function(event) { return (event.name === params.event && (event.properties["$os"] == 'iPhone OS') ) })
        
        .groupByUser(["properties.$model", "properties.App Name"],mixpanel.reducer.count())
        .groupBy(["key.1"], mixpanel.reducer.count())
        .reduce(function(states, object){
          function sortByValue(a, b) {
    				if (a[1] === b[1]) {
    					return 0;
    				}
    				else {
    					return (a[1] < b[1]) ? 1 : -1; // largest to smallest
    				}
    			}
          var testArray = [];
          for (var i = 0; i < object.length;i++){
            var element = [String(object[i].key), object[i].value];
            testArray.push(element);
          }
          var newArray = [];
          var targetItems = ["iPhone8,1", "iPad6,7"];
          testArray.sort(sortByValue);
          for (i = 0; i < testArray.length;i++){
            var newElement = [i+1, testArray[i][0], testArray[i][1]];
            if (targetItems.indexOf((newElement[1])) != -1){
              
                newArray.push(newElement);
            }
          }
          
          return newArray;
        })

      }


*/
/*
// NOTE: For groupBy, MUST use properties.variable instead of properties["variable"] otherwise it returns null!
function main() {
        return Events({
          from_date: params.from_date,
          to_date: params.to_date,
          event_selectors: [{event: params.event}]
        })
        //.filter(function(event) { return (event.name === params.event && (event.properties.Platform == 'iOS') ) })
        
        // Produce list of App Names relevant to selected operating system (in this case, iPhone OS)
        //.groupBy(["properties.App Name"], mixpanel.reducer.count()); // Get App Names
        //.groupBy(["properties.$model"], mixpanel.reducer.count()); // Get Model Names
        //.groupByUser(["properties.$model", "properties.App Name"],mixpanel.reducer.count())
        //.groupBy(["key.1"], mixpanel.reducer.count()) // Key.1 is the key from the groupByUser search
        //.map(function(event){
          //throw total
          //throw event['key'];
        //  return [event['key'], event['value'], 'INSERT RANK HERE'];
        //})
        //.reduce(mixpamnel.reducer.top(5));
        //.reduce(mixpanel.reducer.count());
        .filter(function(event) { return (event.name === params.event ) })
        .groupBy(["properties.Platform"], mixpanel.reducer.count()); // Get App Names

      }
*/
